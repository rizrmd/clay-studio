use super::base::McpHandlers;
use crate::core::mcp::types::*;
use chrono::Utc;
use serde_json::{json, Value};
use sqlx::Row;

mod tools;
use tools::*;

impl McpHandlers {
    /// Get all available MCP tool names for Claude CLI allowed tools configuration
    pub fn get_all_available_mcp_tools() -> Vec<String> {
        tools::registry::get_all_available_mcp_tools()
    }

    pub async fn handle_initialize(&self, params: Option<Value>) -> Result<Value, JsonRpcError> {
        eprintln!(
            "[{}] [INFO] Handling initialize request for project: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            self.project_id
        );
        
        // Extract the protocol version from client request and echo it back
        let client_protocol_version = params
            .as_ref()
            .and_then(|p| p.get("protocolVersion"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
            .unwrap_or_else(|| "2025-06-18".to_string());
            
        eprintln!(
            "[{}] [INFO] Client requested protocol version: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            client_protocol_version
        );
        
        eprintln!(
            "[{}] [INFO] MCP Server fully initialized and ready for requests",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
        );
        
        // Get available tools to include in capabilities
        let tools_list = self.handle_tools_list(None).await?;
        let available_tools = tools_list.get("tools").and_then(|t| t.as_array()).map(|tools| {
            tools.iter().filter_map(|tool| {
                tool.get("name").and_then(|n| n.as_str()).map(|name| name.to_string())
            }).collect::<Vec<String>>()
        }).unwrap_or_default();
        
        eprintln!(
            "[{}] [DEBUG] Advertising {} tools in capabilities: {:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            available_tools.len(),
            available_tools
        );

        let result = InitializeResult {
            protocol_version: client_protocol_version,
            server_info: ServerInfo {
                name: "Clay Studio MCP Server".to_string(),
                version: "1.0.0".to_string(),
            },
            capabilities: Capabilities {
                resources: Some(ResourcesCapability {
                    subscribe: false,  // We don't support subscriptions yet
                    list_changed: false, // Our resource list is static
                }),
                tools: Some(ToolsCapability {
                    list_changed: false, // Our tool list is static
                }),
            },
        };

        Ok(serde_json::to_value(result).map_err(|e| JsonRpcError {
            code: INTERNAL_ERROR,
            message: format!("Failed to serialize response: {}", e),
            data: None,
        })?)
    }

    pub async fn handle_resources_list(
        &self,
        _params: Option<Value>,
    ) -> Result<Value, JsonRpcError> {
        eprintln!(
            "[{}] [INFO] Handling resources/list request for project: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            self.project_id
        );

        let mut resources = vec![Resource {
            uri: format!("claude://project/{}/claude.md", self.project_id),
            name: "CLAUDE.md".to_string(),
            mime_type: "text/markdown".to_string(),
            description: Some("Project documentation and datasource information".to_string()),
        }];

        // Add datasources as resources  
        let datasources = sqlx::query(
            "SELECT id, name, source_type, schema_info FROM data_sources WHERE project_id = $1 AND deleted_at IS NULL"
        )
        .bind(&self.project_id)
        .fetch_all(&self.db_pool)
        .await
        .map_err(|e| JsonRpcError {
            code: INTERNAL_ERROR,
            message: format!("Database error: {}", e),
            data: None,
        })?;

        for datasource in datasources {
            let id: String = datasource.get("id");
            let name: String = datasource.get("name");
            let source_type: String = datasource.get("source_type");
            
            resources.push(Resource {
                uri: format!("datasource://{}", id),
                name: format!("{} ({})", name, source_type),
                mime_type: "application/json".to_string(),
                description: Some(format!("Datasource: {} - {}", name, source_type)),
            });
        }

        Ok(json!({
            "resources": resources
        }))
    }

    pub async fn handle_resources_read(
        &self,
        params: Option<Value>,
    ) -> Result<Value, JsonRpcError> {
        let params = params.ok_or_else(|| JsonRpcError {
            code: INVALID_PARAMS,
            message: "Missing parameters".to_string(),
            data: None,
        })?;

        let uri = params
            .get("uri")
            .and_then(|v| v.as_str())
            .ok_or_else(|| JsonRpcError {
                code: INVALID_PARAMS,
                message: "Missing uri parameter".to_string(),
                data: None,
            })?;

        eprintln!(
            "[{}] [INFO] Handling resources/read request for URI: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            uri
        );

        // Check if this is a CLAUDE.md request
        if uri == format!("claude://project/{}/claude.md", self.project_id) {
            // Get CLAUDE.md content for this project
            let content = sqlx::query_scalar::<_, Option<String>>(
                "SELECT claude_md FROM projects WHERE id = $1",
            )
            .bind(&self.project_id)
            .fetch_optional(&self.db_pool)
            .await
            .map_err(|e| JsonRpcError {
                code: INTERNAL_ERROR,
                message: format!("Database error: {}", e),
                data: None,
            })?
            .flatten()
            .unwrap_or_else(|| {
                "# Clay Studio Project\n\nNo CLAUDE.md content available for this project."
                    .to_string()
            });

            Ok(json!({
                "contents": [
                    {
                        "uri": uri,
                        "mimeType": "text/markdown",
                        "text": content
                    }
                ]
            }))
        } else if uri.starts_with("datasource://") {
            // Handle datasource resource request
            let datasource_id = uri.strip_prefix("datasource://").unwrap_or("");
            
            // Get datasource information
            let datasource = sqlx::query(
                "SELECT id, name, source_type, config, schema_info FROM data_sources WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL"
            )
            .bind(datasource_id)
            .bind(&self.project_id)
            .fetch_optional(&self.db_pool)
            .await
            .map_err(|e| JsonRpcError {
                code: INTERNAL_ERROR,
                message: format!("Database error: {}", e),
                data: None,
            })?
            .ok_or_else(|| JsonRpcError {
                code: INVALID_PARAMS,
                message: format!("Datasource not found: {}", datasource_id),
                data: None,
            })?;

            let name: String = datasource.get("name");
            let source_type: String = datasource.get("source_type");
            let schema_info: Option<String> = datasource.get("schema_info");
            
            // Return JSON content as text for MCP resource
            let content = json!({
                "id": datasource_id,
                "name": name,
                "type": source_type,
                "schema": schema_info.and_then(|s| serde_json::from_str::<serde_json::Value>(&s).ok())
            });

            Ok(json!({
                "contents": [
                    {
                        "uri": uri,
                        "mimeType": "application/json",
                        "text": serde_json::to_string_pretty(&content).unwrap_or_default()
                    }
                ]
            }))
        } else {
            Err(JsonRpcError {
                code: INVALID_PARAMS,
                message: format!("Unknown resource URI: {}", uri),
                data: None,
            })
        }
    }

    pub async fn handle_tools_list(&self, _params: Option<Value>) -> Result<Value, JsonRpcError> {
        eprintln!(
            "[{}] [INFO] Handling tools/list request for project: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            self.project_id
        );

        let mut tools = Vec::new();

        // Only add data analysis tools for data-analysis server type
        if self.server_type == "data-analysis" {
            tools.extend(data_analysis::get_data_analysis_tools());
        }

        // Add interaction-specific tools for interaction server
        if self.server_type == "interaction" {
            tools.extend(interaction::get_interaction_tools());
        }

        Ok(json!({
            "tools": tools
        }))
    }

    pub async fn handle_tools_call(&self, params: Option<Value>) -> Result<Value, JsonRpcError> {
        let params = params.ok_or_else(|| JsonRpcError {
            code: INVALID_PARAMS,
            message: "Missing parameters".to_string(),
            data: None,
        })?;

        let tool_name =
            params
                .get("name")
                .and_then(|v| v.as_str())
                .ok_or_else(|| JsonRpcError {
                    code: INVALID_PARAMS,
                    message: "Missing tool name".to_string(),
                    data: None,
                })?;

        eprintln!(
            "[{}] [DEBUG] Raw params keys: {:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            params.as_object().map(|o| o.keys().collect::<Vec<_>>()).unwrap_or_default()
        );
        
        let default_args = serde_json::Map::new();
        let arguments = params
            .get("arguments")
            .and_then(|v| v.as_object())
            .unwrap_or(&default_args);
            
        eprintln!(
            "[{}] [DEBUG] Arguments keys: {:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            arguments.keys().collect::<Vec<_>>()
        );

        // If arguments is empty, try to use params directly (for Claude compatibility)
        let final_arguments = if arguments.is_empty() && params.as_object().is_some() {
            params.as_object().unwrap()
        } else {
            arguments
        };

        eprintln!(
            "[{}] [INFO] Handling tools/call request for tool: {} in project: {}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            tool_name,
            self.project_id
        );
        
        eprintln!(
            "[{}] [DEBUG] Arguments empty: {}, final_arguments keys: {:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            arguments.is_empty(),
            final_arguments.keys().collect::<Vec<_>>()
        );

        let result = match tool_name {
            // Datasource Tools
            "datasource_add" => self.add_datasource(final_arguments).await,
            "datasource_list" => self.list_datasources(final_arguments).await,
            "datasource_remove" => self.remove_datasource(final_arguments).await,
            "datasource_update" => self.datasource_update(final_arguments).await,
            "connection_test" => self.test_connection(final_arguments).await,
            "datasource_detail" => self.get_datasource_detail(final_arguments).await,
            "datasource_query" => self.query_datasource(final_arguments).await,
            "datasource_inspect" => self.inspect_datasource(final_arguments).await,

            // Schema Tools
            "schema_get" => self.get_schema(final_arguments).await,
            "schema_search" => self.search_schema(final_arguments).await,
            "schema_related" => self.get_related_schema(final_arguments).await,
            "schema_stats" => self.get_schema_stats(final_arguments).await,

            // Interaction Tools (only available on interaction server)
            "ask_user" => {
                if self.server_type == "interaction" {
                    self.handle_ask_user(final_arguments).await
                } else {
                    Err(JsonRpcError {
                        code: -32601,
                        message: "ask_user tool is only available on interaction server"
                            .to_string(),
                        data: None,
                    })
                }
            }

            // Export Tools
            "export_excel" => {
                if self.server_type == "interaction" {
                    self.handle_export_excel(final_arguments).await
                } else {
                    Err(JsonRpcError {
                        code: -32601,
                        message: "export_excel tool is only available on interaction server"
                            .to_string(),
                        data: None,
                    })
                }
            }

            // Show Table Tool
            "show_table" => {
                if self.server_type == "interaction" {
                    self.handle_show_table(final_arguments).await
                } else {
                    Err(JsonRpcError {
                        code: -32601,
                        message: "show_table tool is only available on interaction server"
                            .to_string(),
                        data: None,
                    })
                }
            }
            // Show Chart Tool
            "show_chart" => {
                if self.server_type == "interaction" {
                    self.handle_show_chart(final_arguments).await
                } else {
                    Err(JsonRpcError {
                        code: -32601,
                        message: "show_chart tool is only available on interaction server"
                            .to_string(),
                        data: None,
                    })
                }
            }

            _ => Err(JsonRpcError {
                code: METHOD_NOT_FOUND,
                message: format!("Unknown tool: {}", tool_name),
                data: None,
            }),
        }?;

        // Check if result is JSON, if so use resource type with application/json
        if serde_json::from_str::<Value>(&result).is_ok() {
            Ok(json!({
                "content": [
                    {
                        "type": "resource",
                        "resource": {
                            "uri": format!("mcp://tool-result/{}", tool_name),
                            "title": format!("{} Result", tool_name),
                            "mimeType": "application/json",
                            "text": result,
                            "annotations": {
                                "audience": ["user", "assistant"],
                                "priority": 0.8
                            }
                        }
                    }
                ]
            }))
        } else {
            // Fallback to text for non-JSON responses
            Ok(json!({
                "content": [
                    {
                        "type": "text",
                        "text": result
                    }
                ]
            }))
        }
    }

    pub async fn handle_show_table(
        &self,
        arguments: &serde_json::Map<String, Value>,
    ) -> Result<String, JsonRpcError> {
        eprintln!(
            "[{}] [DEBUG] handle_show_table called with keys: {:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            arguments.keys().collect::<Vec<_>>()
        );
        let title = arguments
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap_or("Data Table");

        // Check if data parameter exists
        let data_param = arguments.get("data");
        eprintln!(
            "[{}] [DEBUG] data_param check: exists={}, value={:?}",
            Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            data_param.is_some(),
            data_param
        );
        if data_param.is_none() {
            let response = json!({
                "status": "error",
                "error": "Invalid parameter format for show_table",
                "message": "Missing required 'data' parameter",
                "correct_format_example": {
                    "data": {
                        "columns": [
                            {"key": "id", "label": "ID", "data_type": "string", "sortable": true},
                            {"key": "name", "label": "Name", "data_type": "string", "filterable": true},
                            {"key": "email", "label": "Email", "data_type": "string", "filterable": true}
                        ],
                        "rows": [
                            {"id": "1", "name": "John Doe", "email": "john@example.com"},
                            {"id": "2", "name": "Jane Smith", "email": "jane@example.com"}
                        ],
                        "config": {
                            "features": {
                                "sort": true,
                                "filter": true,
                                "pivot": true,
                                "columnVisibility": true,
                                "export": false
                            },
                            "initialState": {
                                "sorting": [{"column": "name", "direction": "asc"}]
                            }
                        }
                    },
                    "title": "User Table"
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        }

        // Check if data is in old 2D array format (incorrect)
        if let Some(_data_array) = data_param.and_then(|v| v.as_array()) {
            let response = json!({
                "status": "error",
                "error": "Invalid parameter format for show_table",
                "message": "Expected 'data' to be an object with 'columns' and 'rows' structure, not a 2D array",
                "received_format": "2D array format (deprecated)",
                "correct_format_example": {
                    "data": {
                        "columns": [
                            {"key": "id", "label": "ID", "data_type": "string", "sortable": true, "filterable": true},
                            {"key": "name", "label": "Name", "data_type": "string", "sortable": true, "filterable": true},
                            {"key": "biography", "label": "Biography", "data_type": "string", "filterable": true},
                            {"key": "phone", "label": "Phone", "data_type": "string", "filterable": true},
                            {"key": "slug", "label": "Slug", "data_type": "string", "sortable": true},
                            {"key": "coins", "label": "Coins", "data_type": "number", "sortable": true},
                            {"key": "is_pioneer", "label": "Is Pioneer", "data_type": "boolean", "filterable": true},
                            {"key": "is_checkmark", "label": "Is Checkmark", "data_type": "boolean", "filterable": true}
                        ],
                        "rows": [
                            {
                                "id": "1",
                                "name": "Afif Auliya Nurani",
                                "biography": "Penulis buku self-help dan pengembangan diri",
                                "phone": "+6281234567892",
                                "slug": "afif-auliya-nurani",
                                "coins": 0,
                                "is_pioneer": false,
                                "is_checkmark": false
                            },
                            {
                                "id": "2",
                                "name": "Ainia",
                                "biography": "Halo, nama saya Ainia. Kalian bisa panggil aku Ain. Di sini aku akan menyuguhkan sebuah karya romansa hangat, haru dan dramatis yang mungkin kalian suka, jangan lupa baca ya🥰😍",
                                "phone": null,
                                "slug": "ainia",
                                "coins": 0,
                                "is_pioneer": true,
                                "is_checkmark": false
                            }
                        ],
                        "config": {
                            "features": {
                                "sort": true,
                                "filter": true,
                                "pivot": true,
                                "columnVisibility": true,
                                "export": false
                            },
                            "initialState": {
                                "sorting": [{"column": "name", "direction": "asc"}]
                            }
                        }
                    },
                    "title": "All Authors"
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        }

        // Check if data is an object with columns and rows structure (correct format)
        if let Some(data_obj) = data_param.and_then(|v| v.as_object()) {
            // Validate columns field
            if let Some(columns) = data_obj.get("columns").and_then(|v| v.as_array()) {
                // Validate each column has required fields
                for (i, col) in columns.iter().enumerate() {
                    if let Some(col_obj) = col.as_object() {
                        if !col_obj.contains_key("key") || !col_obj.contains_key("label") || !col_obj.contains_key("data_type") {
                            let response = json!({
                                "status": "error",
                                "error": "Invalid column structure",
                                "message": format!("Column {} must have 'key', 'label', and 'data_type' fields", i),
                                "correct_format_example": {
                                    "key": "column_name",
                                    "label": "Display Name",
                                    "data_type": "string",
                                    "sortable": true,
                                    "filterable": true
                                }
                            });
                            return Ok(serde_json::to_string(&response).unwrap());
                        }
                    } else {
                        let response = json!({
                            "status": "error",
                            "error": "Invalid column structure",
                            "message": format!("Column {} must be an object", i),
                            "correct_format_example": {
                                "key": "column_name",
                                "label": "Display Name", 
                                "data_type": "string",
                                "sortable": true,
                                "filterable": true
                            }
                        });
                        return Ok(serde_json::to_string(&response).unwrap());
                    }
                }

                // Validate rows field
                if let Some(rows) = data_obj.get("rows").and_then(|v| v.as_array()) {
                    if !rows.is_empty() {
                        // Check if first row is an object with keys matching columns
                        if let Some(first_row) = rows[0].as_object() {
                            // Extract column keys for validation
                            let column_keys: Vec<String> = columns
                                .iter()
                                .filter_map(|col| col.get("key").and_then(|k| k.as_str()).map(|s| s.to_string()))
                                .collect();

                            // Check if row has all required keys
                            for key in &column_keys {
                                if !first_row.contains_key(key) {
                                    let response = json!({
                                        "status": "error",
                                        "error": "Row data mismatch",
                                        "message": format!("Row is missing key '{}' defined in columns", key),
                                        "expected_keys": column_keys
                                    });
                                    return Ok(serde_json::to_string(&response).unwrap());
                                }
                            }

                            // Parameters are valid! Return simple success response to Claude
                            let response = json!({
                                "status": "success",
                                "message": "Parameters valid. Table created successfully.",
                                "table_info": {
                                    "title": title,
                                    "columns_count": columns.len(),
                                    "rows_count": rows.len()
                                }
                            });
                            return Ok(serde_json::to_string(&response).unwrap());
                        } else {
                            let response = json!({
                                "status": "error",
                                "error": "Invalid row structure",
                                "message": "Rows must be objects with keys matching column definitions",
                                "correct_format_example": {
                                    "rows": [
                                        {"id": "1", "name": "John", "email": "john@example.com"},
                                        {"id": "2", "name": "Jane", "email": "jane@example.com"}
                                    ]
                                }
                            });
                            return Ok(serde_json::to_string(&response).unwrap());
                        }
                    } else {
                        let response = json!({
                            "status": "error",
                            "error": "Empty rows array",
                            "message": "Rows array cannot be empty"
                        });
                        return Ok(serde_json::to_string(&response).unwrap());
                    }
                } else {
                    let response = json!({
                        "status": "error",
                        "error": "Missing rows field",
                        "message": "Data object must contain a 'rows' array field"
                    });
                    return Ok(serde_json::to_string(&response).unwrap());
                }
            } else {
                let response = json!({
                    "status": "error",
                    "error": "Missing columns field",
                    "message": "Data object must contain a 'columns' array field"
                });
                return Ok(serde_json::to_string(&response).unwrap());
            }
        }

        // If we reach here, data is neither array nor object
        let response = json!({
            "status": "error",
            "error": "Invalid data type",
            "message": "Data parameter must be an object with 'columns' and 'rows' structure"
        });
        Ok(serde_json::to_string(&response).unwrap())
    }

    pub async fn handle_show_chart(
        &self,
        arguments: &serde_json::Map<String, Value>,
    ) -> Result<String, JsonRpcError> {
        let title = arguments
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap_or("Chart");

        // Check for required chart_type parameter
        let chart_type = match arguments.get("chart_type").and_then(|v| v.as_str()) {
            Some(ct) => ct,
            None => {
                let response = json!({
                    "status": "error",
                    "error": "Invalid parameter format for show_chart",
                    "message": "Missing required 'chart_type' parameter",
                    "correct_format_example": {
                        "data": {
                            "categories": ["Product A", "Product B", "Product C"],
                            "series": [
                                {"name": "Q1 Sales", "data": [15000, 23000, 18000]},
                                {"name": "Q2 Sales", "data": [18000, 25000, 21000]}
                            ]
                        },
                        "chart_type": "bar",
                        "title": "Sales by Product"
                    }
                });
                return Ok(serde_json::to_string(&response).unwrap());
            }
        };

        // Validate chart type
        let valid_chart_types = ["line", "bar", "pie", "scatter", "area", "radar", "gauge", "map", "sankey", "treemap"];
        if !valid_chart_types.contains(&chart_type) {
            let response = json!({
                "status": "error",
                "error": "Invalid chart_type",
                "message": format!("Unsupported chart type '{}'. Must be one of: {}", chart_type, valid_chart_types.join(", ")),
                "supported_types": valid_chart_types,
                "correct_format_example": {
                    "chart_type": "bar",
                    "data": {
                        "categories": ["Category 1", "Category 2"],
                        "series": [
                            {"name": "Series 1", "data": [10, 20]}
                        ]
                    },
                    "title": "Sample Chart"
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        }

        // Check for required data parameter
        let data_param = arguments.get("data");
        if data_param.is_none() {
            let response = json!({
                "status": "error",
                "error": "Invalid parameter format for show_chart",
                "message": "Missing required 'data' parameter",
                "correct_format_example": {
                    "data": {
                        "categories": ["iPhone 15", "MacBook Pro", "iPad Air", "AirPods Pro"],
                        "series": [
                            {"name": "Q1 Sales", "data": [45000, 38000, 22000, 15000]},
                            {"name": "Q2 Sales", "data": [52000, 41000, 28000, 18000]}
                        ]
                    },
                    "chart_type": chart_type,
                    "title": title
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        }

        // Validate data structure based on chart type
        if let Some(data_obj) = data_param.and_then(|v| v.as_object()) {
            match chart_type {
                "pie" => {
                    // For pie charts, expect series with name-value pairs
                    if let Some(series) = data_obj.get("series").and_then(|v| v.as_array()) {
                        if !series.is_empty() {
                            if let Some(first_series) = series[0].as_object() {
                                if let Some(data_array) = first_series.get("data").and_then(|v| v.as_array()) {
                                    // Check if data uses name-value objects (correct) or just values (incorrect)
                                    if !data_array.is_empty() && !data_array[0].is_object() {
                                        let response = json!({
                                            "status": "error",
                                            "error": "Invalid pie chart data format",
                                            "message": "Pie chart data must use name-value objects, not just values",
                                            "received_format": "Array of values (incorrect)",
                                            "correct_format_example": {
                                                "data": {
                                                    "series": [{
                                                        "name": "Market Share",
                                                        "data": [
                                                            {"name": "North America", "value": 35},
                                                            {"name": "Europe", "value": 28},
                                                            {"name": "Asia Pacific", "value": 25},
                                                            {"name": "Latin America", "value": 12}
                                                        ]
                                                    }]
                                                },
                                                "chart_type": "pie",
                                                "title": "Market Share Distribution"
                                            }
                                        });
                                        return Ok(serde_json::to_string(&response).unwrap());
                                    }
                                }
                            }
                        }
                    }
                },
                "line" | "bar" | "area" => {
                    // For line/bar/area charts, expect categories and series
                    if !data_obj.contains_key("categories") || !data_obj.contains_key("series") {
                        let response = json!({
                            "status": "error",
                            "error": "Invalid chart data format",
                            "message": format!("{} chart must have 'categories' and 'series' fields", chart_type),
                            "correct_format_example": {
                                "data": {
                                    "categories": ["Jan 2024", "Feb 2024", "Mar 2024", "Apr 2024", "May 2024"],
                                    "series": [
                                        {"name": "Revenue", "data": [120000, 135000, 142000, 158000, 165000]},
                                        {"name": "Target", "data": [115000, 130000, 145000, 160000, 175000]}
                                    ]
                                },
                                "chart_type": chart_type,
                                "title": "Revenue Trend"
                            }
                        });
                        return Ok(serde_json::to_string(&response).unwrap());
                    }

                    // Check for meaningful labels in categories (not generic indices)
                    if let Some(categories) = data_obj.get("categories").and_then(|v| v.as_array()) {
                        if !categories.is_empty() {
                            // Check if categories use generic indices like "0", "1", "2"
                            if categories.iter().any(|cat| {
                                if let Some(cat_str) = cat.as_str() {
                                    cat_str.chars().all(|c| c.is_ascii_digit()) || 
                                    cat_str.starts_with("Item ") || 
                                    cat_str.starts_with("Category ")
                                } else {
                                    false
                                }
                            }) {
                                let response = json!({
                                    "status": "error", 
                                    "error": "Invalid chart labels",
                                    "message": "Chart categories should use meaningful labels from your actual data, not generic indices like '0', '1', '2' or 'Item 1', 'Item 2'",
                                    "received_categories": categories,
                                    "correct_format_example": {
                                        "data": {
                                            "categories": ["iPhone 15", "MacBook Pro", "iPad Air", "AirPods Pro"],
                                            "series": [
                                                {"name": "Q1 Sales", "data": [45000, 38000, 22000, 15000]},
                                                {"name": "Q2 Sales", "data": [52000, 41000, 28000, 18000]}
                                            ]
                                        },
                                        "chart_type": chart_type,
                                        "title": "Monthly Sales by Product"
                                    }
                                });
                                return Ok(serde_json::to_string(&response).unwrap());
                            }
                        }
                    }
                },
                _ => {
                    // For other chart types, basic validation
                    if !data_obj.contains_key("series") {
                        let response = json!({
                            "status": "error",
                            "error": "Invalid chart data format",
                            "message": format!("{} chart must have 'series' field", chart_type),
                            "correct_format_example": {
                                "data": {
                                    "series": [
                                        {"name": "Series 1", "data": [10, 20, 30]}
                                    ]
                                },
                                "chart_type": chart_type,
                                "title": title
                            }
                        });
                        return Ok(serde_json::to_string(&response).unwrap());
                    }
                }
            }

            // Parameters are valid! Return simple success response to Claude
            let response = json!({
                "status": "success",
                "message": "Parameters valid. Chart created successfully.",
                "chart_info": {
                    "title": title,
                    "chart_type": chart_type,
                    "has_categories": data_obj.contains_key("categories"),
                    "series_count": data_obj.get("series")
                        .and_then(|s| s.as_array())
                        .map(|arr| arr.len())
                        .unwrap_or(0)
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        } else if let Some(_data_array) = data_param.and_then(|v| v.as_array()) {
            // Data is an array instead of object - this is incorrect
            let response = json!({
                "status": "error",
                "error": "Invalid data format",
                "message": "Chart data must be an object with proper structure, not a plain array",
                "received_format": "Array (incorrect)",
                "correct_format_example": {
                    "data": {
                        "categories": ["Product A", "Product B", "Product C"],
                        "series": [
                            {"name": "Sales", "data": [100, 200, 150]}
                        ]
                    },
                    "chart_type": chart_type,
                    "title": title
                }
            });
            return Ok(serde_json::to_string(&response).unwrap());
        } else {
            let response = json!({
                "status": "error",
                "error": "Invalid data type",
                "message": "Data parameter must be an object with proper chart structure"
            });
            return Ok(serde_json::to_string(&response).unwrap());
        }
    }
}
